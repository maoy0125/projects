//=================================================================
// Copyright 2023 Georgia Tech.  All rights reserved.
// The materials provided by the instructor in this course are for
// the use of the students currently enrolled in the course.
// Copyrighted course materials may not be further disseminated.
// This file must not be made publicly available anywhere.
//=================================================================

/* 	 Labeling Connected Objects in Hubble-Webb Images

Please fill in the following
Your Name: Yutao Mao
Date: 15/02/2023 

 ECE 2035 Project1-1

This is the only file that should be modified for the C implementation
of Project 1.

Do not include any additional libraries.

FOR FULL CREDIT (on all assignments in this class), BE SURE TO TRY
MULTIPLE TEST CASES and DOCUMENT YOUR CODE.

-----------------------------------------------

This program takes in one 32x32 binary difference image
generated by computing the difference of a pair of corresponding tiles in	
two larger images (generated by Misasim).
It replaces black pixels in the Diff array with labels in the range 1-32,
assigning a unique label to each connected component of adjacent pixels
(adjacency is defined by 8-connectivity: in N, NE, E, SE, S, SW, W, NW 
directions).
White pixels remain unchanged.

The output of this program is a print out of the num of connected 
components, the min size (number of pixels in smallest CC), and max size
(number of pixels in largest CC).
*/

#include <stdio.h>
#include <stdlib.h>

#define DEBUG 0 // RESET THIS TO 0 BEFORE SUBMITTING YOUR CODE

#define BLACK  0x000000
#define WHITE 0xFFFFFF

int  Load_Mem(char *, int *);
int displayCC(int, int D[]);

int main(int argc, char *argv[]) {
  /* you may change and add to these declarations and initializations */
  int	Diff[1024];
  int	Num;
  int numCC=-1, min=-1, max=-1;
  int i = 0;                                                                     /*General count variable*/
  int label = 1;                                                                 //The raw label, which refers to the label after the first pass
  int compCount = 0;                                                             /*Variable used for compare. This index are increased when the computer faces a new label that needs 
                                                                                 to be stored for equivalence and to be changed to smaller number*/
  int targetLabel[1024];                                                           //The array to record labels that are need to be changed in the second pass
  int resultLabel[1024];                                                           //The array to record labels to which labels in target array are changed.

  if (argc != 2) {
    printf("usage: ./HW2-1 valuefile\n");
    exit(1);
  }
  Num = Load_Mem(argv[1], Diff);
  if (Num != 1024) {
    printf("value file must contain 1024 entries\n");
    exit(1);
  }
  
  /* Your program goes here. */
  while (i < 1024) {                                                              //The loop of the first pass
    if (Diff[i] == WHITE){                                                        //To skip the WHITE pixels
      i++;
      continue;
    }
    if (i-32<0) {                                                                 //For pixels in the first line.
      if (i == 0) {                                                               //For the first pixel, if it is not white, this one should be a new label
        Diff[i] = label;
        label += 1;
      }else if (Diff[i-1] == WHITE){                                              //If the left pixel of the current one is WHITE, this one should be a new label
        Diff[i] = label;
        label += 1;
      }else {                                                                     //Or this pixel should be the left one.
        Diff[i] = Diff[i-1];
      }
    }else if (i % 32 == 0) {                                                      //The condition for left boundary pixels
      if ((Diff[i-32] != WHITE) || (Diff[i-31] != WHITE)) {                       //The pixel should be the smaller label if one of the N and NE has a label
        Diff[i] = Diff[i-32] < Diff[i-31] ? Diff[i-32] : Diff[i-31];
        if ((Diff[i-32] > Diff[i])&&(Diff[i-32]!=WHITE)) {                        //To record the equivalence info. The N or NE or both should changed to smaller label 
          int j;
          int exist = 0;
          for (j = 0; j <= compCount; j++) {                                      
            if (targetLabel[j] == Diff[i-32]) {
              exist = 1;
              break;
            }
          }
          if (!exist) {
            targetLabel[compCount] = Diff[i-32];
            resultLabel[compCount] = Diff[i];
            compCount++;
          }
        }
        if ((Diff[i-31] > Diff[i])&&(Diff[i-31]!=WHITE)) {                        //To record the equivalence info. The N or NE or both should changed to smaller label
          int j;
          int exist = 0;
          for (j = 0; j <= compCount; j++) {                                      //Check whether the label that needs to be changed already recored
            if (targetLabel[j] == Diff[i-31]) {
              exist = 1;
              break;
            }
          }
          if (!exist) {                                                          //If not, add the label to the target label array
            targetLabel[compCount] = Diff[i-31];
            resultLabel[compCount] = Diff[i];
            compCount++;
          }
        }
      }else {                                                                   //If neither N nor NE has a label, it has a new label
        Diff[i] = label;
        label += 1;
      }
    }else if ((i + 1) % 32 == 0){                                               //For pixels at right edge
      if ((Diff[i-32] != WHITE)||(Diff[i-33] != WHITE)||(Diff[i-1] != WHITE)) {
        Diff[i] = Diff[i-32] < Diff[i-33] ? Diff[i-32] : Diff[i-33];            //Choose the smallest one in N, NW, and W
        Diff[i] = Diff[i-1] < Diff[i] ? Diff[i-1] : Diff[i];
        if ((Diff[i-32] > Diff[i])&&(Diff[i-32]!=WHITE)) {                      //Similarly, if the N pixel is not white and needs to be changed, record it.
          int j;
          int exist = 0;
          for (j = 0; j <= compCount; j++) {
            if (targetLabel[j] == Diff[i-32]) {
              exist = 1;
              break;
            }
          }
          if (!exist) {
            targetLabel[compCount] = Diff[i-32];
            resultLabel[compCount] = Diff[i];
            compCount++;
          }
        }
        if ((Diff[i-33] > Diff[i])&&(Diff[i-33]!=WHITE)) {
          int j;
          int exist = 0;
          for (j = 0; j <= compCount; j++) {
            if (targetLabel[j] == Diff[i-33]) {
              exist = 1;
              break;
            }
          }
          if (!exist) {
            targetLabel[compCount] = Diff[i-33];
            resultLabel[compCount] = Diff[i];
            compCount++;
          }
        }
        if ((Diff[i-1] > Diff[i])&&(Diff[i-1]!=WHITE)) {
          int j;
          int exist = 0;
          for (j = 0; j <= compCount; j++) {
            if (targetLabel[j] == Diff[i-1]) {
              exist = 1;
              break;
            }
          }
          if (!exist) {
            targetLabel[compCount] = Diff[i-1];
            resultLabel[compCount] = Diff[i];
            compCount++;
          }
        }
      }else {
        Diff[i] = label;
        label += 1;
      }

    }else if ((Diff[i-31] != WHITE)                                                         //For general pixels, check four pixels around it: N, NE, NW, W
            ||(Diff[i-32] != WHITE)
            ||(Diff[i-33] != WHITE)
            ||(Diff[i-1] != WHITE)) {        
      Diff[i] = Diff[i-32] < Diff[i-31] ? Diff[i-32] : Diff[i-31];
      Diff[i] = Diff[i-33] < Diff[i] ? Diff[i-33] : Diff[i];
      Diff[i] = Diff[i-1] < Diff[i] ? Diff[i-1] : Diff[i];
        if ((Diff[i-32] > Diff[i])&&(Diff[i-32]!=WHITE)) {                                  //For each pixel around the current one, check intermediate pixels whether needs to be changed
          int j;
          int exist = 0;
          for (j = 0; j <= compCount; j++) {
            if (targetLabel[j] == Diff[i-32]) {
              exist = 1;
              break;
            }
          }
          if (!exist) {
            targetLabel[compCount] = Diff[i-32];
            resultLabel[compCount] = Diff[i];
            compCount++;
          }
        }
        if ((Diff[i-33] > Diff[i])&&(Diff[i-33]!=WHITE)) {
          int j;
          int exist = 0;
          for (j = 0; j <= compCount; j++) {
            if (targetLabel[j] == Diff[i-33]) {
              exist = 1;
              break;
            }
          }
          if (!exist) {
            targetLabel[compCount] = Diff[i-33];
            resultLabel[compCount] = Diff[i];
            compCount++;
          }
        }
        if ((Diff[i-31] > Diff[i])&&(Diff[i-31]!=WHITE)) {
          int j;
          int exist = 0;
          for (j = 0; j <= compCount; j++) {
            if (targetLabel[j] == Diff[i-31]) {
              exist = 1;
              break;
            }
          }
          if (!exist) {
            targetLabel[compCount] = Diff[i-31];
            resultLabel[compCount] = Diff[i];
            compCount++;
          }
        }
        if ((Diff[i-1] > Diff[i])&&(Diff[i-1]!=WHITE)) {
          int j;
          int exist = 0;
          for (j = 0; j <= compCount; j++) {
            if (targetLabel[j] == Diff[i-1]) {
              exist = 1;
              break;
            }
          }
          if (!exist) {
            targetLabel[compCount] = Diff[i-1];
            resultLabel[compCount] = Diff[i];
            compCount++;
          }
        }
    }else {
      Diff[i] = label;
      label += 1;
    }
    i++;
  }

i=0;

i = compCount;                                     /*Oganize raw equivalence to ultimate equivalence*/
for (i = compCount;i >= 0; i--) {
  int exist = 1;
  while (exist){
    exist = 0;
    int j;
    for (j = 0; j < compCount; j++) {                //Repetitively scan the target array to check the ultimate label for one label to change to
    if (resultLabel[i] == targetLabel[j]) {
      resultLabel[i] = resultLabel[j];
      exist = 1;
    }
   }
  }

}
numCC = label - compCount - 1;                      //The remaining label are max label minus (compare count + 1)

int componentList[numCC];                           //Arrays for compute max and min components
int componentCount[numCC];
int currCount = 0;

i = 0;
while (i < 1024) {                                 //Second pass
  if (Diff[i] == WHITE){
    i++;
    continue;
  }
  int j;
  for (j = 0;j < compCount; j++) {
    if (Diff[i] == targetLabel[j]) {
      Diff[i] = resultLabel[j];                    //Change pixels
      break;
    }
  }
  int exist = 0;                                   
  for (j = 0; j < currCount; j++) {
    if (Diff[i] == componentList[j]) {
      componentCount[j]++;
      exist = 1;
    }
  }
  if (!exist) {
    componentList[currCount] = Diff[i];
    componentCount[currCount] = 1;
    currCount += 1;
  }
  i++;
}

min = componentCount[0];
for (i = 0; i < numCC; i++) {
  if (max < componentCount[i]) {
    max = componentCount[i];
  }
  if (min > componentCount[i]) {
    min = componentCount[i];
  }
}

  /* Use a statement like this to print information helpful to
     debugging (e.g., the current value of some variable).
  */
  if (DEBUG){
    printf("Sample debugging print statement. argc: %d \n", argc);
    printf("These will only show up when DEBUG is set to 1.\n");
    printf("You should wrap DEBUG around any debugging print statements\n");
    printf("you add.  This makes it easy to turn them off so that your\n");
    printf("program doesn't confuse grading scripts with superfluous prints.\n"); 
    printf("You must set DEBUG to 0 before submitting your code.\n");
  }

  /* Use a fragment like this to display a colorized version
     of your labeled image.  Be sure to only use displayCC in
     a DEBUG statement.
   */
  if (DEBUG){
    Diff[130] = Diff[131] = Diff[132] = Diff[133] = Diff[134] = 3;
    Diff[161] = Diff[167] = 3;
    Diff[195] = Diff[197] = 2;
    Diff[193] = Diff[199] = Diff[225] = Diff[231] = Diff[257] = Diff[263] = 3;
    Diff[289] = Diff[295] = Diff[322] = Diff[326] = 3;
    Diff[355] = Diff[356] = Diff[357] = 3;
    Diff[260] = 1;      

    displayCC(Num, Diff);
  }

  /* Use this print statement to report your results.  Do not
     modify this print statement.
   */
  printf("Num Components: %d, min size: %d, max size: %d.\n", numCC, min, max);

  exit(0);
}

/* This routine loads in up to 1024 newline delimited integers from
a named file in the local directory. The values are placed in the
passed integer array. The number of input integers is returned. */

int Load_Mem(char *InputFileName, int Diff[]) {
   int	N, Addr, Value, NumVals;
   FILE	*FP;

   FP = fopen(InputFileName, "r");
   if (FP == NULL) {
     printf("%s could not be opened; check the filename\n", InputFileName);
     return 0;
   } else {
     for (N=0; N < 1024; N++) {
       NumVals = fscanf(FP, "%d: %d", &Addr, &Value);
       if (NumVals == 2)
	 Diff[N] = Value;
       else
	 break;
     }
     fclose(FP);
     return N;
   }
}

const char *colors[] =
  {"\x1b[30;40m",          //0 black
   "\x1b[48;2;255;0;0m",   //1 red
   "\x1b[48;2;0;255;0m",   //2 green
   "\x1b[48;2;0;0;255m",   //3 blue
   "\x1b[48;2;255;0;255m", //4
   "\x1b[48;2;0;255;255m", //5
   "\x1b[48;2;128;0;0m",   //6
   "\x1b[48;2;0;128;0m",   //7
   "\x1b[48;2;0;0;128m",   //8
   "\x1b[48;2;128;128;0m", //9
   "\x1b[48;2;128;0;128m", //10
   "\x1b[48;2;255;255;204m", //11 (different than Misasim palette)
   "\x1b[48;2;0;128;128m",   //12
   "\x1b[48;2;153;153;255m", //13
   "\x1b[48;2;128;128;128m", //14
   "\x1b[48;2;153;51;102m",  //15
   "\x1b[48;2;102;0;102m",   //16
   "\x1b[48;2;204;255;255m", //17
   "\x1b[48;2;255;128;128m", //18
   "\x1b[48;2;204;102;51m",  //19 (different than Misasim palette)
   "\x1b[48;2;204;204;255m", //20
   "\x1b[48;2;0;204;255m",   //21
   "\x1b[48;2;204;255;204m", //22
   "\x1b[48;2;153;204;255m", //23
   "\x1b[48;2;255;153;204m", //24
   "\x1b[48;2;204;153;255m", //25
   "\x1b[48;2;255;204;153m", //26
   "\x1b[48;2;51;102;51m",   //27 (different than Misasim palette)
   "\x1b[48;2;51;204;204m",  //28
   "\x1b[48;2;153;204;0m",   //29
   "\x1b[48;2;255;204;0m",   //30
   "\x1b[48;2;102;102;153m", //31
   "\x1b[48;2;255;102;0m"    //32
  };

#define RESET      "\x1b[0m"

/* This function takes in a labeled image array of 1024 pixel values
in which each Value is either 0xFFFFF (White), 0 (Black), or a
label between 1-32, inclusive.

It displays the image as a color map depending on the Value in each
pair: White, Black (colors[0]), or colors[label].

Assumes labels are btwn 1-32.
*/

int displayCC(int Num, int Image[]) {
   char interval[6];
   int i, Label;
   const char *color;
   printf(" 0: ");
   for (i = 0; i<Num; i++) {  
     Label = Image[i];
     if (Label == 16777215){
       color =    "\x1b[30;47m"; // white
     }
     else {
       if ((Label < 0) || (Label > 32)){
	 printf("Image[%d]'s label %d is out of range.\n", i, Label);
	 Label = Label%(sizeof(colors)/sizeof(char));
       }
       color = colors[Label];
     }
     snprintf(interval, sizeof(interval), "%%%dd", 3);
     printf("%s", color); // start highlighting in label's color
     printf(interval, i%32);
     printf(RESET); // stop highlighting
     if (i%32 == 31)
       printf("\n%2d: ", (i/32)+1);
   }
   printf("\n");
   return(0);
}

