#=================================================================
# Copyright 2023 Georgia Tech.  All rights reserved.
# The materials provided by the instructor in this course are for
# the use of the students currently enrolled in the course.
# Copyrighted course materials may not be further disseminated.
# This file must not be made publicly available anywhere.
# =================================================================
#
#	 Labeling Connected Objects in Hubble-Webb Images
#
# Please fill in the following
# Your Name: Yutao Mao
# Date: 20/02/2023
# 
# ECE 2035 Project1-2
#
# This program takes in one 32x32 binary difference image (generated by swi 602
# by computing the difference of a pair of corresponding tiles in	
# two larger images and placed into memory at Diff).
# It replaces black pixels in the Diff array with labels in the range 1-32,
# assigning a unique label to each connected component of adjacent pixels
# (adjacency is defined by 8-connectivity: in N, NE, E, SE, S, SW, W, NW 
# directions).
# White pixels remain unchanged.
#
# The program reports the results with swi 604:
#     $1 Base addr of labeled array
#     $4 num components, $5 min size, $6 max size 
# Oracle:
#     $2 number labeling errors
#     $7 correct num components, $8 correct min size, $9 correct max size
# Labeling errors:
#     black pixel not labeled,
#     white pixel not white,
#     labels out of range [1-32] inclusive
#     labels in memory are not consistent with correct CC labeling.
#	
#===========================================================================
# CHANGE LOG: brief description of changes made from P1-2-shell.asm
# to this version of code.
# Date  Modification
# 02/19 In the first pass, change the label of first line.         
# 02/20 In the first pass, change the label of the most left column 
# 02/21 Finish the first pass.
# 02/25 Finish the pixel recording method
# 03/01 Finish the second pass
# 03/02 Finish the max and min counter
#===========================================================================

.data
Diff:        .alloc	1024		# allocate binary threshold image space
CompCount: .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

.text
CC:	addi	$1, $0, Diff		# set memory base
	addi    $2, $0, 66		# TileNum to start with
	swi	602			# create and display images
          addi $1, $0, 0              #The index i
          addi $2, $0, 1                    #The label
          addi $3, $0, 0                  #The compCount
                 lui $28, 0x00FF
                 ori $28, $28, 0xFFFF    #WHITE
                 addi $20, $31, 0 # preserve $31
                 addi $19, $29, 0 #preserve $29
                 addi $22, $0, 4096
LoopOne:         beq $1, $22, Org
                 lw $10, Diff($1)               #For Diff[i]
                 beq $10, $28, Continue   #Skip white pixel
                 slti $11, $1, 128
                 beq $11, $0, NotFirstLine   #if i >= 32, the pixel is not in the first line
                 bne $1, $0, NotFirstPixel    #If i=0, label it
                 sw $2, Diff($1)               #Neither labeled before, new label
                       addi $2,$2,1
                 j Continue
NotFirstPixel:  addi $11, $1, -4
                        lw $10, Diff($11)               #Get previous one
                 bne $10, $28, LabelFirstLine      #The previous pixel is not white, label it with previous one
                 sw $2, Diff($1)               #Neither labeled before, new label
                       addi $2,$2,1
                 j Continue
LabelFirstLine:      sw $10, Diff($1)         #Label this pixel as the previous one
                 j Continue
  
NotFirstLine:         addi $11, $1, -124
                      lw $10, Diff($11)                 #Load Diff[i-31]
                      addi $11, $11, -4                 # i-32
                      lw $12, Diff($11)                  #Load Diff[i-32]
                      addi $11, $0, 128
                      div $1, $11
                      mfhi $11
                      bne $11, $0, NotLeftCol     #If i % 32 != 0, it is not on the leftmost col 
                      bne $10, $28, LeftCol        #Diff[i-31] is not white
                      bne $12, $28, LeftCol        #Diff[i-32] is not white
                      sw $2, Diff($1)               #Neither labeled before, new label
                       addi $2,$2,1
                      j Continue
LeftCol:          slt $11,$10,$12                     #Compare Diff[i-31] and Diff[i-32]
                      beq $11, $0, LCgreater     #Jump to the case: Diff[i-32] <= Diff[i-31]
                      sw $10, Diff($1)                    #Store less one: Diff[i-32]
                      add $8, $0, $10
                      add $11, $0, $12
                    jal recordPixel                     #Record equivalence
                      j Continue
LCgreater:    sw $12, Diff($1)                  #Diff[i-31] >= Diff[i-32], store Diff[i-32]
                      add $11, $0, $10
                      add $8, $0, $12
                    jal recordPixel                    #Record equivalence
                      j Continue
NotLeftCol:           addi $11, $1, -132
                      lw $13, Diff($11)                    #$12 Diff[i-32], Load Diff[i-33]
                      addi $11, $1, -4                     
                      lw $14, Diff($11)                     #$14 Load Diff[i-1]  
                     addi $11, $1, 4                       #i+1
                     addi $16, $0, 128
                      div $11, $16
                      mfhi $11                                #(i + 1) % 32
                      bne $11, $0, GeneralPixel     #Check if it is on the right col, or it is ordinary pixel           
                      bne $12, $28, RightCol
                      bne $13, $28, RightCol
                      bne $14, $28, RightCol
                      sw $2, Diff($1)               #Neither labeled before, new label
                       addi $2,$2,1
                      j Continue
RightCol:      slt $11, $12, $13                       #Compare Diff[i-32] and Diff[i-33]. 
                     beq $11, $0,  RCComp33And1         #if Diff[i-32] >= Diff[i-33], go to compare Diff[i-33] and Diff[i-1]
                     add $16, $0, $12
                     add $15, $0, $13                    #Record the greater one in [1-32] and [i-33]
                     #jal recordPixel                    
                     j RCComp1
RCComp33And1:               add $16, $0, $13
                             add $15, $0, $12                   #Record the greater one in [1-32] and [i-33]
RCComp1:             slt $11, $16, $14
                     beq $11, $0, RC1less
                     sw $16, Diff($1)                          #Diff[i-33] or Diff[i-32] is less than Diff[i-1]
                     add $11, $0, $14
                     add $8, $0, $16
                     jal recordPixel                           #Record equivalence
                     add $11, $0, $15
                     jal recordPixel                           #Record equivalence
                     j Continue
RC1less:      sw $14, Diff($1)                           #Diff[i-1] is the smallest one
                     add $8, $0, $14
                    add $11, $0, $12
                     jal recordPixel                    #Record equivalence
                     j Continue
                    add $11, $0, $13
                    jal recordPixel                     #Record equivalence
                     j Continue
GeneralPixel:          bne $10, $28, GPChoose
                       bne $12, $28, GPChoose
                       bne $13, $28, GPChoose
                       bne $14, $28, GPChoose         #Check if one is not white
                       sw $2, Diff($1)               #Neither labeled before, new label
                       addi $2,$2,1
                       j Continue
GPChoose:          slt $11, $10, $12
                   beq $11, $0, GPCho32              #Diff[i-32] is less
                   add $15, $0, $10
                   add $16, $0, $12
                   #jal recordPixel                  
                  j GPComp33
GPCho32:           add $15, $0, $12
                   add $16, $0, $10
                   #jal recordPixel                    
GPComp33:          slt $11, $15, $13                    #Compared with Diff[i-33]
                   beq $11, $0, GPCho33              #Diff[i-33] is less
                   add $17, $0, $13
                   j GPComp1
GPCho33:          add $17, $0, $15
                  add $15, $0, $13     
                  #jal recordPixel                    
 GPComp1: slt $11, $15, $14                       #Compared with Diff[i-1]
                    beq $11, $0, GPCho1
                    sw $15 Diff($1)
                    add $8, $0, $15
                    add $11, $0, $14
                    jal recordPixel                 #Record equivalence
                    add $11, $0, $16
                    jal recordPixel                 #Record equivalence
                    add $11, $0, $17
                    jal recordPixel                 #Record equivalence
                    j Continue
GPCho1:             sw $14 Diff($1)
                    add $8, $0, $14
                    add $11, $0, $10
                    jal recordPixel                 #Record equivalence
                    add $11, $0, $12
                    jal recordPixel                 #Record equivalence
                    add $11, $0, $13
                    jal recordPixel                 #Record equivalence
Continue: addi $1, $1, 4
                 j LoopOne

recordPixel:  beq $11, $28, Skip
              beq $11, $8, Skip
              add $7, $3, $0
              addi $18, $29, 4
MinorLoop:    beq $7, $0, Add
              lw $21, 0($18)
              bne $21, $11, ContiMinorLoop
              lw $21, -4($18)
              beq $21, $8, Skip
              slt $21, $8, $21
              bne $21, $0, Skip
              j Skip1
ContiMinorLoop: addi $18, $18, 8
                addi $7, $7, -1
                j MinorLoop
Add:            addi $29, $29, -8
                sw $11, 4($29)
                sw $8, 0($29)
                addi $3, $3, 1
                j Skip
Skip1:          addi $29, $29, -8
                sw $8, 4($29)
                lw $21, -4($18)
                sw $21, 0($29)
                addi $3, $3, 1
Skip:             jr $31

Org:          sll $7, $3, 3
              beq $19, $29, LoopTwo
              add $10, $7, $29           #n
              addi $11, $10, -8          #n-8, the result[0]
              addi $8, $29, -4            #$29 -4, the "last target"
              addi $9, $29, -8
LoopOrgFor:   addi $12, $10, -4          #n-4, the target[0]           
              lw $13, 0($11)             #result[i]
              lw $16, 4($11)             #target[i]
              beq $16, $0,NextResul
              addi $15, $0, 1
LoopInFor:    beq $15, $0, NextResul
              addi $15, $0, 0
              addi $12, $10, -4
While:        lw $14, 0($12)             #target[j]
              bne $14,$16,InWhile
              addi $17, $11, 4
              beq $12, $17, InWhile
              sw $0, 0($12)
              addi $3, $3, -1
              j NextTar
InWhile:      bne $13, $14, NextTar
              lw $13, -4($12)
              sw $13, 0($11)
              addi $15,$0, 1
NextTar:      addi $12, $12, -8
              beq $12, $8, LoopInFor
              j While             
NextResul:    addi $11, $11, -8
              beq $11, $9, LoopTwo
              j LoopOrgFor

LoopTwo:      sub $4, $2, $3
              addi $4, $4, -1      
              addi $1, $0, 0
LoopOfTwo:    beq $1, $22, MaxMin
              lw $15, Diff($1)
              beq $15, $28, Then
              beq $19, $29,Then1
              addi $12, $10, -4          #n-4, the target[0]
LoopFindChange:  beq $12, $8, Then1
              lw $11, 0($12)
              bne $11, $15, ThenTar
              lw $15, -4($12)
              sw $15, Diff($1)
Then1:        sll $15, $15, 2
              lw $5, CompCount($15)
              addi $5, $5, 1
              sw $5, CompCount($15)  
Then:         addi $1, $1, 4
              j LoopOfTwo
ThenTar:      addi $12, $12, -8
              j LoopFindChange

MaxMin:       addi $1, $0, 0
              addi $5, $0, 0
              addi $6, $0, 0
              sll $2, $2, 2
MLoop:        lw $10, CompCount($1)
              beq $10, $0, Next
              beq $5, $0, Value
              slt $11, $5, $10
              bne $11, $0, Max
              add $5, $0, $10
Max:          slt $11, $6, $10
              beq $11, $0, Next
              add $6, $0, $10
              j Next
Value:        add $5,$0,$10
              add $6,$0,$10
Next:         addi $1, $1, 4
              beq $1, $2, Report
              j MLoop


              
	######################################################################
	# FOR DEBUGGING ONLY: comment out any use of swi 603 before submitting

	#addi    $2, $0, 5     	      	# TEMP: replace this
	#addi    $3, $0, 16		# TEMP: replace this
	#sw      $2, Diff($3)		# TEMP: replace this
	#addi    $3, $3, 4		# TEMP: replace this
	#sw      $2, Diff($3)		# TEMP: replace this
	#addi    $3, $3, 4		# TEMP: replace this
	#sw      $2, Diff($3)		# TEMP: replace this
	#addi    $3, $3, 4		# TEMP: replace this
	
	#addi    $1, $0, Diff		# Set $1 to base address of subarray
	#swi 603 	      	        # displays labeled subarray currently
	    				# in memory w/out checking answer or
					# calling the oracle.
					# This can be used to check intermediate
					# results in an incomplete program
	######################################################################


Report:  add $29, $29, $7
      addi $31, $20, 0 # restore $31
	addi    $1, $0, Diff
	swi     604			# Report results
	jr      $31
